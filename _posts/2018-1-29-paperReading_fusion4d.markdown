---
layout:     post
title:      "论文阅读(1)——fusion4D 论文阅读笔记"
subtitle:   ""
date:       2018-01-29 23:30:00
author:     "Stonlimart"
#header-img: "img/post-bg-nextgen-web-pwa.jpg"
header-mask: 0.3
catalog:    true
tags:
    - 论文阅读
    - 读书笔记
    - 计算机图形学
    - 三维建模
---

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script>

<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js">
</script>



## Abstract

本文提出了一个在线多视角动态捕捉，实时生成高质量时序三维重建的系统。我们的算法支持同时增量重建，和随时间推移提高重建质量，同时支持参数化非刚性场景运动。该算法对大量帧到帧的移动和拓扑变化是鲁棒的，从而允许我们重建极其有挑战性的场景。本文描述了相关的实时技术的有点，包括对在线生成的模型进行形变，还有连续将深度数据非刚性的融合到参考帧中。最后给出了几何重建结果，该方法能够实现实时高质量的重建效果。

## 1.  Instruction

## 2.  Related work

## 3.  System Overview

Fusion 4D 尝试将多视角捕捉系统固有的特性带入实时三维场景重建。为此，我们需要重新设计一个流水线系统，来克服当前实时非刚性重建系统的限制。换句话说，就是要对快速的移动和拓扑变化鲁棒，并且支持多视角输入，而且能够保持实时的处理帧率。下面是总的系统展示：

![系统总览](./fusion4d.png)

## 4.  Raw Depth

使用kinect8组相机，每组两个IR相机和一个RGB相机获得深度。方法为支持倾斜窗口的patch match

## 5.  Nonrigid Motion Filed Estimation

对于每个帧，我们观测到$N$个深度图$\{\mathbb{D}_n\}_{n=1}^N$，还有$N$张前景mask。本文将深度数据积累成为一个由截断符号距离函数(TSDF)隐式表示的非参数话的表面或者参考体素$\mathbb{V}$(我们成为关键帧/体素)。这能够实现有效的对齐，而且能够极大的减少噪声，将所有数据平均化为一个完整的表面。而且，TSDF的过零点容易被定位从而提取出一个高质量的网格$V = \{v_m\}_{m=1}^M \subseteq R^3$ 和与之相匹配的法向量$ \{v_m\}_{m=1}^M$。本节的目标是展示如何构建一个变形场来对关键帧进行变形，使之与当前帧的深度图对其。我们将参考体素$\mathbb{V}$或者网格$V$称为模型。$\{\mathbb{D}_n\}_{n=1}^N$称为数据。

### 5.1  变形模型

我们采用embedded deformation model (ED)模型来参数化非刚性变形场。在处理新的一帧数据之前，我们对网格$V$进行的采样位置$\{g_k\}_{k=1}^K$进行均匀采样得到K个“ED nodes“来得到参考帧。网格上的每个顶点$\mathbf{v}_m$将被”皮肤化“到他的m个最邻近ED点$S_m \subseteq\{1,\dots,K\}$使用固定的皮肤化权值$\{w_k : w_k^m = \frac{1}{z}exp(||\mathbf{v}_m-\mathbf{g}_k||^2/2\sigma^2)\}$,在此，用于Z是一个归一化的常数来保证权值和为1。$\sigma$定义了ED nodes的有效半径，在此我们设置$\sigma = 0.5d$，$d$在此处表示采样后相邻ED nodes的平均距离。

接下来，我们使用放射变换(旋转变换)$A_k\in R^{3\times3}$和平移变换$t_k \in R^3$. 除此之外，还有全局旋转矩阵$R$和平移$T$。因此集合$G = \{R,T\}\cup\{A_k,t_k\}_{k=1}^K$完全参数化了变形，因此将点$\mathbf{v}$变形为

​$$\mathcal{T}(\mathbf{v}_m;G) = R \sum_{k \in S_m}w_k^m[A_k(\mathbf{v}_m-\mathbf{g}_k)+\mathbf{g}_k+\mathbf{t}_k]+T$$	 

同样，该点的法向量 $n$ 被变形为：

​		$$\mathcal{T}^{\bot}(\mathbf{n}_m;G) = R \sum_k \in S_mw_k^mA_k^{-T}\mathbf{n}_m$$	

法向量会在后面用到。

### 5.2  能量函数

为了估计参数$G$，建立一个能量函数$E(G)$来惩罚模型和观测数据间的未对齐，对变形类型进行正则化，和对其他一些特性和限制进行编码。能量函数是：

​		$$E(G) = \lambda_{data}E_{data}(G)+ \lambda_{hull}E_{hull}(G)+ \lambda_{corr}E_{corr}(G)+ \lambda_{rot}E_{rot}(G)+ \lambda_{smooth}E_{smooth}(G)$$	(3)

下面对上述分量逐一介绍.

#### 5.2.1  数据项

能量函数最重要的部分是对形变模型和数据的未对齐进行惩罚的数据项。它的一般格式如下：

​					$\hat{E}_{data} = \sum_{n=1}^{N}\sum_{m=1}^M \min_{x\in P(\mathbb{D}_n)}||\mathcal{T}(\mathbf{T}_m;G)-x||^2$  (4)

其中$P(\mathbb{D}_n)$从深度图$\mathbb{D}_n$提取出点云。

然而我们采用了点到面的投影方法来对此项进行近似，写作：

​					$E_{data}(G) = \sum_{n=1}^{N}\sum_{m\in \mathcal{V}_n(G)} (\tilde{\mathbf{n}}_m(G)^T(\tilde{\mathbf{v}}_m(G)-\Gamma_n(\tilde{\mathbf{v}}_m(G))))^2 $ 	(5)

其中$\tilde{\mathbf{n}}_m(G) = \mathcal{T}^{\bot}(\mathbf{n}_m;G) $ and $\tilde{\mathbf{v}}_m(G) = \mathcal{T}(\mathbf{v}_m;G)$ 而且 $\Gamma_n(\mathbf{v}) = P_n(\Pi_n(\mathbf{v}))$，其中$\Pi_n$：是空间三维点到第n个深度图的映射$\mathbb{R}^3\to\mathbb{R}^2$,而$P_n$则是将第n个深度图中的点映射到三维空间中的点$\mathbb{R}^2\to \mathbb{R}^3$.其中$\mathcal{V}_n(G)\subseteq\{1,\dots,M\}$是使用$G$进行形变时第n个视角下能够看到的网格上的顶点。

特别的在此考虑能够看见的顶点满足：

> * $\Pi_n(\mathbf{\tilde{v}_m})$是有效的而且在第n个深度图中是可见的。
> * $||\tilde{\mathbf{v}}_m-\Gamma_n(\tilde{\mathbf{v}}_m)|| \leq \epsilon_d$ 而且
> * $\tilde{\mathbf{n}}_m^TP_n^{\bot}(\Pi_n(\mathbf{\tilde{v}}_m)) < \epsilon_n$ 

$P_n^{\bot}:\mathbb{R}^2\to \mathbb{R}^3$是从第n个深度图中估测的法向量$ \epsilon_d $和$ \epsilon_n$是深度和法向量的截断阈值。

尽管(5)只是(4)的近似，但它有很多优点。首先，点到面的投影是一个有名的能够加速收敛的算法。第二，投影相关性避免了高昂的最小化计算代价。最后，可视化数据集能鲁棒的用于计算能够明显的避免减缓高斯牛顿法迭代。

#### 5.2.2  正则项

因为上述形变模型很容易导致不合理的形变，因此这里使用两个正则项来约束形变类型。第一项是：

​					$E_{rot}(G) = \sum_{k=1}^{K}||A_k^TA_k-\mathbf{I}||_F+\sum_{k=1}^K(det(A_k)-1)^2$    (6)

该项鼓励局部形变接近刚性变形

第二项鼓励临近的仿射变换与下面类似

​					$E_{smooth}(G) = \sum_{k=1}^K\sum_{j\in\mathcal{N}_k}w_{jk}\rho(||A_j(g_k-g_j)+g_j+t_j-(g_k+t_k)||^2)$	(7)

其中 $w_{jk} = \exp(-||g_k-g_j||^2/2\sigma^2)$ 是平滑项权值。$\mathcal{N}_k$表示ED nodes的近邻点。

####5.2.3	可视壳项

数据项仅仅是约束了当变化的模型靠近数据集时的形变。假设当前我们有一个完美的变化模型能够完全与数据集对齐。如果这模型的一部分现在被变形到了深度阈值范围之外，则他的梯度就会变成0。换句话说，更为基础的问题是，未被观测到的模型的一部分将会进入自由空间。但是我们知道自由空间是不能被为观测到的数据占用。

未解决这一问题，本文建立一个能量函数来对“形变应在可视区域（可视壳）之内”的约束进行编码。在单目视角下有很多被遮挡的区域，在多目视觉下，遮挡的区域会少很多。因而这项就能对数据遗失的自由空间进行限制。比如，深度相机很难获取对于人的头发数据，但是多视角下的可视壳限制依然能提供一个头部本应该存在的tight bounding box。没有这一项，未对齐的数据可能将会积累更多的误差数据。

可视壳数据可以表示为一个占位体$\mathbb{H}$，可视区域内的值为1，外部的值为0。$\mathbb{H}$中的每个体素都被投影到每个深度图中，如果投影点在背景mask或者到相机的距离比到深度是深度图像素近，则设置为0。为了将可视壳约束应用于我们的代价函数中，我们首先要计算一个到可视壳的近似距离变换$\mathcal{H}$，对于在可视内，则距离应该为0。所以可视壳项可被写为下式：

​					$E_{hull}(G) = \sum_{m=1}^M\mathcal{H}(\mathcal{T}(\mathbf{v}_m;G)^2$	(8)

准确的计算$\mathcal{H}$的计算代价是很高而且不能实现实时，相反，我们通过对占有模型进行高斯模糊来对H进行近似，他的GPU实现是很有效的。

#### 5.2.4	相关匹配项

找到非刚性表面的3D移动场是极度有挑战性的任务。非凸的优化方法很容易在因为比较差的起始点得到局部最优解。因此我们的目标是找到像素级对应的匹配点来为算法提供鲁棒的初始点。找到图像间可靠的匹配点已经是被深入研究过的了。最近以来，深度学习技术已经展现了更好的表现。可是这些计算代价是很高的，现在难为达到实时性的要求。

在本文中，我们扩展了最近提出的Global Patch Collider（GPC）的算法框架来生成准确的RGBD的匹配点数据。GPC可以在线性时间内找到匹配点，避免了在所有候选点上计算代价距离函数。这个方法使用了决策树方法而且能够实现完全并行化。在训练阶段，是在离线的有标签数据上进行的，在测试阶段，相关性预测是完全集成在实时系统的流水线上，而且不需要用户进行手动训练。

给两张时序连续的RGB图片$I_s, I_t$，我们的目标是找到像素位置之间的局部相关性。我们考虑像素$I$中的一个中心坐标为$P$的局部patch $X$，将其通过一个决策树直到到达叶子结点。这个叶子节点可以被解释为这个patch的hash key。只有当像素块到达同样的叶子节点时，GPC才会将它们作为匹配点。为了增加召回率，我们同时将像素快通过多颗树，他们最终的唯一交集被认为是匹配点。我们不需要模板模型，仅在像素块级别，计算两张图的相关性，随后我们的测试和训练都与场景中具体的物体无关。

之前有研究者使用多尺度图片描述子来保证尺度和透视变换的鲁棒性。在这里，我们使用深度数据来扩展他们的方法，这保障了尺度不变性。我们也根据投票方案来使用不同的策略来进行匹配检索。正式的，我们分割节点包含一个学习到的参数集合$\delta = (\mathbf{u},\mathbf{v},\theta)$，在这里$ (\mathbf{u},\mathbf{v})$是2D像素偏置，$\theta$表示一个阈值。在点P处的分割函数被表示为：

​					$$f(p,\theta) = \begin{cases}L \quad if \quad I_s(\mathbf{p}+\mathbf{u}/d_s)-I_t(\mathbf{p}+\mathbf{v}/d_t) < \theta\\ R \quad  other wise \end{cases}$$   (9)

这里$d_s = \mathbb{D}_s(\mathbf{p}),d_t = \mathbb{D}_t(\mathbf{p})​$。用当前点的深度来正则化这些偏置能提供尺度因子的不变性。这种像素差异测试因为其有效性和强大的描述性，经常被用在决策森林的描述中。

在训练阶段，我们选用分割函数来最大化像素块相关性的准确率和召回率的加权调和平均。Ground truth数据通过离线但精确的非刚性bundle是适应方法来获得。我们尝试了不同的算法配置，最后经验发现15层的5棵树能给出准确率和召回率的最好平衡。在测试阶段，当简单的像素差异被用作特征，因为RGB图像的透视变换，这个交叉策略并不鲁棒。但单颗树不能所有可能的像素块变换。多树交叉也不能检索RGBD中的匹配数据。

未解决上述问题，我们将所有树联合在一起，因此建模了所有图像变换。但简单的联合方法会生成很多错误，我们用加权投票的方法来解决这个问题。每棵树对所有的patch都有独立的投票权。这种方法可以生成更多密集而且可靠性更强的相关点，即使在大量的移动下。

上述方法能给我们提供第n个视角下的前后两帧的像素匹配集$F_n = \{u_{nf}^{prev},u_{nf}\}_{f = 1}^{N_f}$。对于每对匹配点$(u_{nf}^{prev},u_{nf})$，我们都能用如下公式在参考帧中找到一个空间点$\mathbf{q}_{nf} \in \mathbb{R}^3$:

​					$\mathbf{q}_{nf} = arg\min_\mathbf{v}\in V ||\Pi_n(\mathcal{T}(\mathbf{v};G^{prev}))-u_{nf}^{prev}|| $	(10)

其中$G^{prev}$是将参考帧变形为上一帧的形变参数。现在我们鼓励这些点变形到他们的3D对应点中。因此能量函数为：

​					$E_{corr}(G) = \sum_{n=1}^N\sum_{f=1}^{F_n}\rho(||\mathcal{T}(\mathbf{q}_{nf};G)-P_n(u_{nf})||^2)$	(11)

这里$\rho$是一个解决相关性概念的鲁棒器。

​				

### 5.3 	优化

这部分主要介绍如何在GPU上快速鲁棒的最小化$E(G)​$从而获得模型和数据帧之间的对齐。为了这个目标，我们用$X \in \mathbb{R}^D​$表示所有参数的拼接，让$f(X) \in \mathbb{R}^C​$的每项输入都包含C的每个非平方项。所以能量函数能够被表示为$E(G) = f(X)^Tf(X)​$。在这种形式下，最小化$E(G)​$问题能被看作一个标准的稀疏最小二乘问题，这可以用高斯牛顿法来求解。

对于每一帧数据，我们用前一帧的变形场来初始化参数。固定ED nodes的参数$\{A_k,t_k\}_{k = 1}^K$然后用投影迭代最邻近点来估计全局刚性移动参数$\{R,T\}$。然后固定全局参数来优化ED nodes的参数。下面阐述优化具体细节：

#### 5.3.1	计算一步方向

我们在GPU上以LM解法的方式计算一步前进方向$h \in \mathbb{R}^D$.因此在搜索空间中的任意点$X$，解下式：

​					$(J^TJ+\mu I)h = -J^Tf$	(12)

$\mu$是一个衰减因子，$J \in \mathbb{R}^{C\times D}$是$f(X)$的雅可比矩阵。如果更新能够使得能量降低( i.e. $E(X+h)<E(X)$ ,那么 $X \gets X+h$，衰减因子也降低更多。)如果能量增加了，则此步长被拒绝，则增加衰减因子然后再次计算(12)式。

**per-Iteration Approximation** 为了解决能量函数$E_{data}(G)$的非差异性并提高性能。在每轮迭代开始，我们复制当前的参数$G_0\gets G$来构造一个$E_{data}(G)$的差分近似 

​					$\tilde{E}_{data}(G) = \sum_{n=1}^{N}\sum_{m\in \mathcal{V}_n(G_0)} (\tilde{\mathbf{n}}_m(G_0)^T(\tilde{\mathbf{v}}_m(G_0)-\Gamma_n(\tilde{\mathbf{v}}_m(G_0))))^2 $。   	（13）

除了能够被微分之外,$\tilde{\mathbf{n}}_m$的独立性大大简化了必要的导数计算，因为$G$中的每个一个参数带任意视角下的导数都是一样的。

**Evaluation of $J^TJ$ and $J^T\mathbf{f}$**  为了使得这个算法易于处理大量参数，我们毙掉了传统的估计和评测雅可比矩阵$J$的方法，在传统方法中，$J$能用于计算 $J^TJ$ 和 $J^T\mathbf{f}$。相反，通过给定的$X$直接估计$J^TJ$和$J^Tf$。在我们的场景中，我们的方法有显著的更少的内存占用，同时最大限度的减少内存读写。这是因为我们问题中残差的数量远远大于参数的数量，因此$J^TJ$远比$J$小。

还有，$J^TJ$本身是一个由K个ED节点中排序的参数块所形成的非0块$\{\mathbf{h}_{ij}\in\mathbb{R}^{12\times 12}:i,j \in \{1,\cdots,K\} i~j\}$组成的.

**Linear Equations Solver**  求解方程式（3）中的代价函数。动态融合直接使用了 稀疏Cholesky分解。考虑到他们将$J^TJ$的数据项分量近似为快对角阵，这仍然是一个实时系统。但是，我们不想通过近似$J^TJ$来压缩重建的保真度，因此我们选择PCG进行迭代求解。$J^TJ$的对角块将作为预先条件使用。

我们的线性求解器方法类似于【】，但是但是我们使用$J^TJ$和$J^Tf$实现求解器，而不是使用$Jf$和$J^Tf$。这两种方法都能有效求解大量的残差数据，但我们的方法需要更少的雅可比估计因此速度更快。为了执行稀疏矩阵向量乘法，我们使用一个warp级的方法来优化内核。

### 5.4	实现细节

在我们的实验中，我们将体分辨率设为4mm，Marching cube 提取一个带有250k个顶点的网格。在多相机捕捉系统下，表面的每个顶点都可能会被多个视角下的相机观察到。我们实验中总的残差数量大约式100w，数据项和可视壳项构成了其中的大多数。我们每4厘米采样一个ED node，则这会大概总共有2000个ED nodes,和24k个参数。

$J^TJ$的稀疏性绝大程度上有两个参数决定。$|\mathcal{S}_m|$，网格表面顶点被皮肤化到的最邻近ED nodes 的个数和 $|\mathcal{N}_k|$,用于正则化cost项的与k相关联的EDnodes的最邻近点的数量。我们分别令其=4与8。从而生成$J^TJ$大概15k个非零块。

我们在LM求解器迭代5轮来估计所有非刚性参数，在每一轮LM求解中，PCG求解器迭代10轮。

## 6.	融合

非刚性的匹配阶段可以估计用于将模型与输入数据对齐的变形场。这种对齐能被用于将数据融合为一个立体模型从而减少模型噪声，将模型变形到当前数据帧。之前已经有将第一针作为参考帧进行融合变形的工作，这对于简单的模型是很work的。但是实验表明他对于现实的场景并不能很好的work。

用单个参考帧来解释所有可能的帧是很多困难也几乎不可能的。在无约束的的现实场景中，后一帧可能会引入动态形变甚至是完全不同的表面拓扑。因为当前的变形场不允许模型的这些不连续进行建模，所以上述方法就会出现问题。第二，期待非刚性的跟踪不会失败是不现实的，在一些点上变形的模型将可能是不真实的。

我们通过重新设计融合流水线来解决这一问题。我们的黄金标准是从估计的模型获得的时序信息绝对不能降低观测模型的质量。换句话说，积累的模型应该通过加入累计的细节或者填补因为遮挡或没能捕捉到的空洞来升级的数据帧。在这个标准下，我们设计了一个旨在提高重建质量和保真度的数据融合流水线，在实现这个目标过程中有两个关键的特征：

1. **数据帧**  在之前的工作都在维持一个参考帧或者参考模型，称为$\mathbb{V}^r$的同时，我们也在维持数据帧$\mathbb{V}^d$，根据非刚性对齐，我们将当前帧数据融合到参考帧中。随后我们也将参考帧数据融合到数据帧中。融合$\mathbb{V}^d$将对于来以至于上面参考帧的数据时非常有选择性的。这让我们保证了即使在在不太好的对齐下，融合数据的质量不会比观测到的数据帧质量低。接下来使用融合的数据得更好的重建结果。
2. **关键帧**  关键帧策略让我们能够持续的维持一个高质量的参考模型来应对跟踪失败。与仅仅简单的将参考帧固定为第一帧不同，我们通过周期性的将参考模型重置为融合的数据帧来应对剧烈的不对齐。我们称之为关键帧。除此之外，我们检测模型-数据间的未对齐，并且使用数据帧中的相关体素来刷新未对齐的体素。

###6.1   在数据帧的融合

#### 6.1.1 帧形变

我们用两步层次化这个体帧。每一个体素$\mathbf{x} \in \mathbb{R}^3$ 都有一个带符号的距离值和一个权重$<d,w>$

在任一轮迭代开始，都要首先从深度图中采样一个数据帧$\mathbb{V}^d$，然后对当前参考帧$\mathbb{V}^r$使用估计的变形场变形到这个数据帧并且与数据进行融合。ED图将参考帧与数据帧对齐。同样的前向变形函数(1)还可以用于参考帧中体素$\mathbf{x}^r$变形为$\tilde{\mathbf{x}}^r = \mathcal{T}(\mathbf{x}^r;G)$。变形后的体素将会用他的数据$<d^r,w^r>$对他的距离为$\tau$ 以内的规则网格内的邻居体素的进行一个投票。每个该范围内的体素$\mathbf{x}^d$将会对累积的$<\bar{d}^r,w^r>$然后用对应权$ w = \exp{-||\hat{\mathbf{x}}^2-\mathbf{x}^d||^2/2\sigma^2}$计算加权平均，得到变化后的$\mathbf{x}^d$ SDF值。

注意到这种平均将会引起一些几何模糊，为了改善这种状况，每个参考帧上的体素不直接对他携带的SDF值直接投票，而是用SDF的梯度场获得的矫正的值$\bar{d}$ 的来进行计算。

$\bar{d}^r = d^r+(\tilde{\mathbf{x}}^r-\mathbf{x}^d)^T\tilde{\Delta} $	

$\Delta$是在参考帧变形前$\mathbf{x^r}$的梯度，$\tilde{\Delta}$是变形后的梯度。而且近似在数据帧的梯度场	。换句话说，$\bar{d}$是在给定了$\tilde{\mathbf{x}}^r$的SDF值和梯度后，在$\mathbf{x}^d$处的SDF值的预测。

#### 6.1.2    选择性融合

为了保证在数据帧上高保真的重建效果，我们需要保证变形后的参考体素$\mathbf{\tilde{x}}^r$不会破坏重建结果。为了这个结果，进行了两个融合之前的测试并且对失败的体素进行去除。

**Voxel Collision.**	当模型的两部分朝向彼此运动时，比如击掌，两个不同表面上的参考体素会在击掌后发生碰撞，在这时，用这些像素进行SDF平均会导致问题，在最坏情况下，拥有高SDF绝对值的体素将会盖过过零点的体素，导致模型空洞。

为了解决这一问题，我们将融合通过两步。在第一步，对于任何给定的体素$\mathbf{x}^d$,我们对其所有参考体素的投票值，然后保存SDF绝对值最小的体素。第二步，拒绝任何参考体素$|\mathbf{x}^r-\dot{\mathbf{x}}^r|>\eta$的投票权。

**Voxel Misalignment** 我们需要评价每个参考体素$\mathbf{x}^r$的proxy error来检测非刚性的跟踪失败以此来拒绝他的投票权。为了解决这个问题，我们首先要计算每个变形后的点$\tilde{\mathbf{x}}^r$的对齐误差。

​					$e_{\tilde{\mathbf{x}}^r} = \begin{cases}|\mathcal{D^d(\tilde{\mathbf{x}}^r)}|\quad   \mathcal{H}^d(\tilde{\mathbf{x}}^r) =0 \\ \min(|\mathcal{D^d(\tilde{\mathbf{x}}^r)}|,\mathcal{H}^d(\tilde{\mathbf{x}}^r))\quad otherwise\end{cases}$	(16)

在这里$D^d$是数据帧中融合的TSDF，$\mathcal{H}^d$是可视壳距离变换函数（5.2.3节）。然后我们通过平均与同样的ED nodes相关联的顶点的错误，在ED nodes聚合这项误差。聚合过程减少了深度数据噪声在对齐误差上的影响。最后，我们拒绝那些任意邻居ED nodes的对齐误差都超过阈值的参考帧体素。

#### 6.1.3    Volume blending

当我们将深度图融合为数据帧$\mathbb{V}^d$并且变形参考帧到数据帧上得到$\tilde{\mathbb{V}}^r$后，最后的一步是混合$\mathbb{V}^d$和$\tilde{\mathbb{V}}^r$从而得到最后融合的数据帧$\bar{\mathbb{V}}^d$作为重建的输出。

即使在经过上述保守的选择融合后，简单的将参考帧和数据帧加权平均会导致重影。这种简单的融合并不能保证过零点附近的SDF带的值存在平滑的过度。这是因为在上述拒绝阶段存活下来的边界体素会抑制任何来自数据的过零点，从而导致重影降低输出质量。

为解决上述问题，我们将参考帧表面网格的顶点$V^r$投影到深度图空间。然后计算每个像素的深度对齐误差——顶点深度$d$和他对应的投影深度$d_{proj}$ ，并用最大深度正则化。总的来说就是计算：

​					$e_{pixel} = \begin{cases}\min(1.0,|d-d_{proj}|/d_{\max}) \quad d_{proj} 有效 \\ 1.0 \quad otherwise\end{cases}$	（17）

数据帧$\mathbb{V}^d$中的每个体素,当将其投影到深度图上时，都能有一个聚合的多张深度图的平均对齐误差$e_{voxel}$。那么最后我们使用如下的融合函数

​					$\bar{d}^d = \frac{\tilde{d}^r\tilde{w}^r(1-e_{voxel})+d^dw^d}{\tilde{w}^r(1-e_{voxel})+w^d}$	(18)

通过他的深度未对齐来降低参考帧数据的权重。

### 6.2	在参考帧的融合

为了更新参考帧模型，我们将每个参考体素变形到数据帧，而后将其投影到深度图上，更新他的TSDF值和权重。这种方法避免了明显的数据到模型的变形。除此之外，我们从（16）式中也可以知道，变形后的参考体素不会很好的和数据帧对齐。对于这些点，我们丢弃他们原来的值，而用当前数据帧上的数据来刷新他。最后，我们周期性的用融合的最后融合的帧$\bar{\mathbb{V}}^d$来重置整个参考模型来解决不能通过点刷新而修复的大量点的不对齐。

## 7	结果










